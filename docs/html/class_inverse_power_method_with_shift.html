<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: InversePowerMethodWithShift&lt; Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_inverse_power_method_with_shift-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">InversePowerMethodWithShift&lt; Scalar &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for solving eigenvalue problems using the inverse power method with shift.  
 <a href="class_inverse_power_method_with_shift.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_inverse_power_method_with_shift_8h_source.html">InversePowerMethodWithShift.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for InversePowerMethodWithShift&lt; Scalar &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_inverse_power_method_with_shift.png" usemap="#InversePowerMethodWithShift_3C_20Scalar_20_3E_map" alt=""/>
  <map id="InversePowerMethodWithShift_3C_20Scalar_20_3E_map" name="InversePowerMethodWithShift_3C_20Scalar_20_3E_map">
<area href="class_abstract_power_method.html" title="A class for solving eigenvalue problems using the power method." alt="AbstractPowerMethod&lt; Scalar &gt;" shape="rect" coords="0,56,242,80"/>
<area href="class_eigenvalue_solver.html" title="Eigenvalue solver base class This class is the base class for all eigenvalue solvers...." alt="EigenvalueSolver&lt; Scalar &gt;" shape="rect" coords="0,0,242,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad22748c8309bc7c612a0ef442c388634" id="r_ad22748c8309bc7c612a0ef442c388634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_inverse_power_method_with_shift.html#ad22748c8309bc7c612a0ef442c388634">setMatrix</a> (const Eigen::MatrixX&lt; Scalar &gt; &amp;mat)</td></tr>
<tr class="memdesc:ad22748c8309bc7c612a0ef442c388634"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the matrix. This method sets the matrix to be used in the inverse power method, and computes its inverse, with shift.  <br /></td></tr>
<tr class="separator:ad22748c8309bc7c612a0ef442c388634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d8a3f19e5a4dc59de407acc081e12c" id="r_a58d8a3f19e5a4dc59de407acc081e12c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_inverse_power_method_with_shift.html#a58d8a3f19e5a4dc59de407acc081e12c">setShift</a> (Scalar sh)</td></tr>
<tr class="memdesc:a58d8a3f19e5a4dc59de407acc081e12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the shift. This method sets the shift to be used in the inverse power method.  <br /></td></tr>
<tr class="separator:a58d8a3f19e5a4dc59de407acc081e12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_abstract_power_method"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_abstract_power_method')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:a8489f099bef0ccd781a360d7411226c4 inherit pub_methods_class_abstract_power_method" id="r_a8489f099bef0ccd781a360d7411226c4"><td class="memItemLeft" align="right" valign="top">Eigen::VectorX&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a8489f099bef0ccd781a360d7411226c4">getEigenvalues</a> () const override</td></tr>
<tr class="separator:a8489f099bef0ccd781a360d7411226c4 inherit pub_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba213413c66a365b6ed36999f39da5c2 inherit pub_methods_class_abstract_power_method" id="r_aba213413c66a365b6ed36999f39da5c2"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#aba213413c66a365b6ed36999f39da5c2">getEigenvectors</a> () const</td></tr>
<tr class="memdesc:aba213413c66a365b6ed36999f39da5c2 inherit pub_methods_class_abstract_power_method"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eigenvectors.  <br /></td></tr>
<tr class="separator:aba213413c66a365b6ed36999f39da5c2 inherit pub_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa89e944cac620e349e00dc292077cb inherit pub_methods_class_abstract_power_method" id="r_afaa89e944cac620e349e00dc292077cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#afaa89e944cac620e349e00dc292077cb">setTolerance</a> (Scalar tol) override</td></tr>
<tr class="memdesc:afaa89e944cac620e349e00dc292077cb inherit pub_methods_class_abstract_power_method"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the tolerance.  <br /></td></tr>
<tr class="separator:afaa89e944cac620e349e00dc292077cb inherit pub_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb50254522abfc125b4bda4344f86e67 inherit pub_methods_class_abstract_power_method" id="r_acb50254522abfc125b4bda4344f86e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#acb50254522abfc125b4bda4344f86e67">setMaxIterations</a> (int maxIter)</td></tr>
<tr class="memdesc:acb50254522abfc125b4bda4344f86e67 inherit pub_methods_class_abstract_power_method"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations.  <br /></td></tr>
<tr class="separator:acb50254522abfc125b4bda4344f86e67 inherit pub_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_eigenvalue_solver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_eigenvalue_solver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:a6c498d6e8992255afbcae1c355a8284d inherit pub_methods_class_eigenvalue_solver" id="r_a6c498d6e8992255afbcae1c355a8284d"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~EigenvalueSolver</b> ()</td></tr>
<tr class="memdesc:a6c498d6e8992255afbcae1c355a8284d inherit pub_methods_class_eigenvalue_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Eigenvalue Solver object. <br /></td></tr>
<tr class="separator:a6c498d6e8992255afbcae1c355a8284d inherit pub_methods_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac1b76fc1caaa3cef3d41c516d0951d inherit pub_methods_class_eigenvalue_solver" id="r_afac1b76fc1caaa3cef3d41c516d0951d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> ()</td></tr>
<tr class="memdesc:afac1b76fc1caaa3cef3d41c516d0951d inherit pub_methods_class_eigenvalue_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method implemented by the solver. It will perform iterations until the solver has converged to the desired tolerance. The results can be obtained using the getEigenvalues() and getEigenvectors() functions. <br /></td></tr>
<tr class="separator:afac1b76fc1caaa3cef3d41c516d0951d inherit pub_methods_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a241de203906c8f1d8ccdfdbb7ec02d07" id="r_a241de203906c8f1d8ccdfdbb7ec02d07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_inverse_power_method_with_shift.html#a241de203906c8f1d8ccdfdbb7ec02d07">performIteration</a> ()</td></tr>
<tr class="memdesc:a241de203906c8f1d8ccdfdbb7ec02d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform an iteration. This method performs an iteration of the inverse power method with shift.  <br /></td></tr>
<tr class="separator:a241de203906c8f1d8ccdfdbb7ec02d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95025eb346b33cd9d5f6066145705bf1" id="r_a95025eb346b33cd9d5f6066145705bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_inverse_power_method_with_shift.html#a95025eb346b33cd9d5f6066145705bf1">obtainResults</a> ()</td></tr>
<tr class="memdesc:a95025eb346b33cd9d5f6066145705bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">obtain the results. This method obtains the results of the inverse power method with shift. It retrieves the eigenvector from iteration. Then, it computes the eigenvalue using the Rayleigh quotient. Finally, it stores the results in the corresponding attributes.  <br /></td></tr>
<tr class="separator:a95025eb346b33cd9d5f6066145705bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_abstract_power_method"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_abstract_power_method')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:ac377ae388628fc3d4ef0012ed262e93c inherit pro_methods_class_abstract_power_method" id="r_ac377ae388628fc3d4ef0012ed262e93c"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_near</b> (const double &amp;a, const double &amp;b, const double &amp;tolerance)</td></tr>
<tr class="separator:ac377ae388628fc3d4ef0012ed262e93c inherit pro_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ebaa30a7f89b18b7ec67c93e3a77c inherit pro_methods_class_abstract_power_method" id="r_a7d8ebaa30a7f89b18b7ec67c93e3a77c"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkEigenVector</b> ()</td></tr>
<tr class="separator:a7d8ebaa30a7f89b18b7ec67c93e3a77c inherit pro_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4922cdc16e9699fabf2980ebde9df7a3 inherit pro_methods_class_abstract_power_method" id="r_a4922cdc16e9699fabf2980ebde9df7a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a4922cdc16e9699fabf2980ebde9df7a3">hasConverged</a> ()</td></tr>
<tr class="memdesc:a4922cdc16e9699fabf2980ebde9df7a3 inherit pro_methods_class_abstract_power_method"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the eigenvalue solver has converged.  <br /></td></tr>
<tr class="separator:a4922cdc16e9699fabf2980ebde9df7a3 inherit pro_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917fb6dda82b47b5375424123dcef374 inherit pro_methods_class_abstract_power_method" id="r_a917fb6dda82b47b5375424123dcef374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a917fb6dda82b47b5375424123dcef374">initialize</a> ()</td></tr>
<tr class="memdesc:a917fb6dda82b47b5375424123dcef374 inherit pro_methods_class_abstract_power_method"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the eigenvalue solver.  <br /></td></tr>
<tr class="separator:a917fb6dda82b47b5375424123dcef374 inherit pro_methods_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_abstract_power_method"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_abstract_power_method')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:a87aa341344e7b327243b91623631186c inherit pro_attribs_class_abstract_power_method" id="r_a87aa341344e7b327243b91623631186c"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>matrix</b></td></tr>
<tr class="separator:a87aa341344e7b327243b91623631186c inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a879c4e8030a9c2cae276044b35d02 inherit pro_attribs_class_abstract_power_method" id="r_a94a879c4e8030a9c2cae276044b35d02"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxIterations</b></td></tr>
<tr class="separator:a94a879c4e8030a9c2cae276044b35d02 inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22459a61d54babfe6b64b25f0cdf374d inherit pro_attribs_class_abstract_power_method" id="r_a22459a61d54babfe6b64b25f0cdf374d"><td class="memItemLeft" align="right" valign="top">
Eigen::NumTraits&lt; Scalar &gt;::Real&#160;</td><td class="memItemRight" valign="bottom"><b>tolerance</b></td></tr>
<tr class="separator:a22459a61d54babfe6b64b25f0cdf374d inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b570154312103ccf7482c0c2b6de2e4 inherit pro_attribs_class_abstract_power_method" id="r_a5b570154312103ccf7482c0c2b6de2e4"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>currentVector</b></td></tr>
<tr class="separator:a5b570154312103ccf7482c0c2b6de2e4 inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ffcc76d19fcc673634724c8c2a0f23 inherit pro_attribs_class_abstract_power_method" id="r_af2ffcc76d19fcc673634724c8c2a0f23"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>previousVector</b></td></tr>
<tr class="separator:af2ffcc76d19fcc673634724c8c2a0f23 inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cdba21cc622ac500a5fcb15231d212 inherit pro_attribs_class_abstract_power_method" id="r_af1cdba21cc622ac500a5fcb15231d212"><td class="memItemLeft" align="right" valign="top">
Eigen::VectorX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvalues</b></td></tr>
<tr class="separator:af1cdba21cc622ac500a5fcb15231d212 inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc1b358cf5c42dd799e0d74ba52e863 inherit pro_attribs_class_abstract_power_method" id="r_a6fc1b358cf5c42dd799e0d74ba52e863"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvectors</b></td></tr>
<tr class="separator:a6fc1b358cf5c42dd799e0d74ba52e863 inherit pro_attribs_class_abstract_power_method"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_eigenvalue_solver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_eigenvalue_solver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:a4d3fe671d4609b1eace96fdd375e691f inherit pro_attribs_class_eigenvalue_solver" id="r_a4d3fe671d4609b1eace96fdd375e691f"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>converged</b></td></tr>
<tr class="separator:a4d3fe671d4609b1eace96fdd375e691f inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26e235a817aecdc1dcca9fb7895877a inherit pro_attribs_class_eigenvalue_solver" id="r_ab26e235a817aecdc1dcca9fb7895877a"><td class="memItemLeft" align="right" valign="top">
Eigen::VectorX&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvalues</b></td></tr>
<tr class="separator:ab26e235a817aecdc1dcca9fb7895877a inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfa4ca80eca46340fa3f1b321d33112 inherit pro_attribs_class_eigenvalue_solver" id="r_a1dfa4ca80eca46340fa3f1b321d33112"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvectors</b></td></tr>
<tr class="separator:a1dfa4ca80eca46340fa3f1b321d33112 inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73406b02a4b863bc7a2ee9135a6fad inherit pro_attribs_class_eigenvalue_solver" id="r_a0e73406b02a4b863bc7a2ee9135a6fad"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentIteration</b></td></tr>
<tr class="separator:a0e73406b02a4b863bc7a2ee9135a6fad inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Scalar&gt;<br />
class InversePowerMethodWithShift&lt; Scalar &gt;</div><p>A class for solving eigenvalue problems using the inverse power method with shift. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="class_inverse_power_method_with_shift.html" title="A class for solving eigenvalue problems using the inverse power method with shift.">InversePowerMethodWithShift</a> is a class that solves eigenvalue problems using the inverse power method with shift. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a95025eb346b33cd9d5f6066145705bf1" name="a95025eb346b33cd9d5f6066145705bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95025eb346b33cd9d5f6066145705bf1">&#9670;&#160;</a></span>obtainResults()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_inverse_power_method_with_shift.html">InversePowerMethodWithShift</a>&lt; Scalar &gt;::obtainResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>obtain the results. This method obtains the results of the inverse power method with shift. It retrieves the eigenvector from iteration. Then, it computes the eigenvalue using the Rayleigh quotient. Finally, it stores the results in the corresponding attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p>Implements <a class="el" href="class_abstract_power_method.html#a074145e5f9b7bba3b4badae2444f9657">AbstractPowerMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a241de203906c8f1d8ccdfdbb7ec02d07" name="a241de203906c8f1d8ccdfdbb7ec02d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241de203906c8f1d8ccdfdbb7ec02d07">&#9670;&#160;</a></span>performIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_inverse_power_method_with_shift.html">InversePowerMethodWithShift</a>&lt; Scalar &gt;::performIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform an iteration. This method performs an iteration of the inverse power method with shift. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p>Implements <a class="el" href="class_abstract_power_method.html#a4cd27a187ca517837cae4c3d2dc34857">AbstractPowerMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="ad22748c8309bc7c612a0ef442c388634" name="ad22748c8309bc7c612a0ef442c388634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22748c8309bc7c612a0ef442c388634">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_inverse_power_method_with_shift.html">InversePowerMethodWithShift</a>&lt; Scalar &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixX&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the matrix. This method sets the matrix to be used in the inverse power method, and computes its inverse, with shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_invalid_input_exception.html" title="A class for exceptions thrown by the solvers during input validation. This class is used when an inpu...">InvalidInputException</a></td><td>if the matrix is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_abstract_power_method.html#a2fd59264b44472e4106bcfbeed3cd86a">AbstractPowerMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a58d8a3f19e5a4dc59de407acc081e12c" name="a58d8a3f19e5a4dc59de407acc081e12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d8a3f19e5a4dc59de407acc081e12c">&#9670;&#160;</a></span>setShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_inverse_power_method_with_shift.html">InversePowerMethodWithShift</a>&lt; Scalar &gt;::setShift </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the shift. This method sets the shift to be used in the inverse power method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>The shift to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/romeu/Desktop/cse_epfl/ma3/eigenvalue-pcsc/include/algorithms/<a class="el" href="_inverse_power_method_with_shift_8h_source.html">InversePowerMethodWithShift.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
