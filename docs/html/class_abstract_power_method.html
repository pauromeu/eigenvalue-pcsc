<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: AbstractPowerMethod&lt; Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_abstract_power_method-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AbstractPowerMethod&lt; Scalar &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A class for solving eigenvalue problems using the power method.  
 <a href="class_abstract_power_method.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_abstract_power_method_8h_source.html">AbstractPowerMethod.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AbstractPowerMethod&lt; Scalar &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_abstract_power_method.png" usemap="#AbstractPowerMethod_3C_20Scalar_20_3E_map" alt=""/>
  <map id="AbstractPowerMethod_3C_20Scalar_20_3E_map" name="AbstractPowerMethod_3C_20Scalar_20_3E_map">
<area href="class_eigenvalue_solver.html" title="Eigenvalue solver base class This class is the base class for all eigenvalue solvers...." alt="EigenvalueSolver&lt; Scalar &gt;" shape="rect" coords="378,0,620,24"/>
<area href="class_inverse_power_method.html" title="A class for solving eigenvalue problems using the inverse power method." alt="InversePowerMethod&lt; Scalar &gt;" shape="rect" coords="0,112,242,136"/>
<area href="class_inverse_power_method_with_shift.html" title="A class for solving eigenvalue problems using the inverse power method with shift." alt="InversePowerMethodWithShift&lt; Scalar &gt;" shape="rect" coords="252,112,494,136"/>
<area href="class_power_method.html" title="A class for solving eigenvalue problems using the power method." alt="PowerMethod&lt; Scalar &gt;" shape="rect" coords="504,112,746,136"/>
<area href="class_power_method_with_shift.html" title="A class for solving eigenvalue problems using the power method with shift." alt="PowerMethodWithShift&lt; Scalar &gt;" shape="rect" coords="756,112,998,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8489f099bef0ccd781a360d7411226c4" id="r_a8489f099bef0ccd781a360d7411226c4"><td class="memItemLeft" align="right" valign="top">Eigen::VectorX&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a8489f099bef0ccd781a360d7411226c4">getEigenvalues</a> () const override</td></tr>
<tr class="separator:a8489f099bef0ccd781a360d7411226c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba213413c66a365b6ed36999f39da5c2" id="r_aba213413c66a365b6ed36999f39da5c2"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#aba213413c66a365b6ed36999f39da5c2">getEigenvectors</a> () const</td></tr>
<tr class="memdesc:aba213413c66a365b6ed36999f39da5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the eigenvectors.  <br /></td></tr>
<tr class="separator:aba213413c66a365b6ed36999f39da5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd59264b44472e4106bcfbeed3cd86a" id="r_a2fd59264b44472e4106bcfbeed3cd86a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a2fd59264b44472e4106bcfbeed3cd86a">setMatrix</a> (const Eigen::MatrixX&lt; Scalar &gt; &amp;mat)=0</td></tr>
<tr class="memdesc:a2fd59264b44472e4106bcfbeed3cd86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix.  <br /></td></tr>
<tr class="separator:a2fd59264b44472e4106bcfbeed3cd86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa89e944cac620e349e00dc292077cb" id="r_afaa89e944cac620e349e00dc292077cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#afaa89e944cac620e349e00dc292077cb">setTolerance</a> (Scalar tol) override</td></tr>
<tr class="memdesc:afaa89e944cac620e349e00dc292077cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the tolerance.  <br /></td></tr>
<tr class="separator:afaa89e944cac620e349e00dc292077cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb50254522abfc125b4bda4344f86e67" id="r_acb50254522abfc125b4bda4344f86e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#acb50254522abfc125b4bda4344f86e67">setMaxIterations</a> (int maxIter)</td></tr>
<tr class="memdesc:acb50254522abfc125b4bda4344f86e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations.  <br /></td></tr>
<tr class="separator:acb50254522abfc125b4bda4344f86e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_eigenvalue_solver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_eigenvalue_solver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:a6c498d6e8992255afbcae1c355a8284d inherit pub_methods_class_eigenvalue_solver" id="r_a6c498d6e8992255afbcae1c355a8284d"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~EigenvalueSolver</b> ()</td></tr>
<tr class="memdesc:a6c498d6e8992255afbcae1c355a8284d inherit pub_methods_class_eigenvalue_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Eigenvalue Solver object. <br /></td></tr>
<tr class="separator:a6c498d6e8992255afbcae1c355a8284d inherit pub_methods_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac1b76fc1caaa3cef3d41c516d0951d inherit pub_methods_class_eigenvalue_solver" id="r_afac1b76fc1caaa3cef3d41c516d0951d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> ()</td></tr>
<tr class="memdesc:afac1b76fc1caaa3cef3d41c516d0951d inherit pub_methods_class_eigenvalue_solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method implemented by the solver. It will perform iterations until the solver has converged to the desired tolerance. The results can be obtained using the getEigenvalues() and getEigenvectors() functions. <br /></td></tr>
<tr class="separator:afac1b76fc1caaa3cef3d41c516d0951d inherit pub_methods_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac377ae388628fc3d4ef0012ed262e93c" id="r_ac377ae388628fc3d4ef0012ed262e93c"><td class="memItemLeft" align="right" valign="top"><a id="ac377ae388628fc3d4ef0012ed262e93c" name="ac377ae388628fc3d4ef0012ed262e93c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_near</b> (const double &amp;a, const double &amp;b, const double &amp;tolerance)</td></tr>
<tr class="separator:ac377ae388628fc3d4ef0012ed262e93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ebaa30a7f89b18b7ec67c93e3a77c" id="r_a7d8ebaa30a7f89b18b7ec67c93e3a77c"><td class="memItemLeft" align="right" valign="top"><a id="a7d8ebaa30a7f89b18b7ec67c93e3a77c" name="a7d8ebaa30a7f89b18b7ec67c93e3a77c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkEigenVector</b> ()</td></tr>
<tr class="separator:a7d8ebaa30a7f89b18b7ec67c93e3a77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4922cdc16e9699fabf2980ebde9df7a3" id="r_a4922cdc16e9699fabf2980ebde9df7a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a4922cdc16e9699fabf2980ebde9df7a3">hasConverged</a> ()</td></tr>
<tr class="memdesc:a4922cdc16e9699fabf2980ebde9df7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the eigenvalue solver has converged.  <br /></td></tr>
<tr class="separator:a4922cdc16e9699fabf2980ebde9df7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd27a187ca517837cae4c3d2dc34857" id="r_a4cd27a187ca517837cae4c3d2dc34857"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a4cd27a187ca517837cae4c3d2dc34857">performIteration</a> ()=0</td></tr>
<tr class="memdesc:a4cd27a187ca517837cae4c3d2dc34857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single iteration of the solver All solver are iterative. This function performs a single iteration of the solver.  <br /></td></tr>
<tr class="separator:a4cd27a187ca517837cae4c3d2dc34857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917fb6dda82b47b5375424123dcef374" id="r_a917fb6dda82b47b5375424123dcef374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a917fb6dda82b47b5375424123dcef374">initialize</a> ()</td></tr>
<tr class="memdesc:a917fb6dda82b47b5375424123dcef374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the eigenvalue solver.  <br /></td></tr>
<tr class="separator:a917fb6dda82b47b5375424123dcef374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074145e5f9b7bba3b4badae2444f9657" id="r_a074145e5f9b7bba3b4badae2444f9657"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_power_method.html#a074145e5f9b7bba3b4badae2444f9657">obtainResults</a> () override=0</td></tr>
<tr class="memdesc:a074145e5f9b7bba3b4badae2444f9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the results of the eigenvalue solver.  <br /></td></tr>
<tr class="separator:a074145e5f9b7bba3b4badae2444f9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a87aa341344e7b327243b91623631186c" id="r_a87aa341344e7b327243b91623631186c"><td class="memItemLeft" align="right" valign="top"><a id="a87aa341344e7b327243b91623631186c" name="a87aa341344e7b327243b91623631186c"></a>
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>matrix</b></td></tr>
<tr class="separator:a87aa341344e7b327243b91623631186c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a879c4e8030a9c2cae276044b35d02" id="r_a94a879c4e8030a9c2cae276044b35d02"><td class="memItemLeft" align="right" valign="top"><a id="a94a879c4e8030a9c2cae276044b35d02" name="a94a879c4e8030a9c2cae276044b35d02"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxIterations</b></td></tr>
<tr class="separator:a94a879c4e8030a9c2cae276044b35d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22459a61d54babfe6b64b25f0cdf374d" id="r_a22459a61d54babfe6b64b25f0cdf374d"><td class="memItemLeft" align="right" valign="top"><a id="a22459a61d54babfe6b64b25f0cdf374d" name="a22459a61d54babfe6b64b25f0cdf374d"></a>
Eigen::NumTraits&lt; Scalar &gt;::Real&#160;</td><td class="memItemRight" valign="bottom"><b>tolerance</b></td></tr>
<tr class="separator:a22459a61d54babfe6b64b25f0cdf374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b570154312103ccf7482c0c2b6de2e4" id="r_a5b570154312103ccf7482c0c2b6de2e4"><td class="memItemLeft" align="right" valign="top"><a id="a5b570154312103ccf7482c0c2b6de2e4" name="a5b570154312103ccf7482c0c2b6de2e4"></a>
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>currentVector</b></td></tr>
<tr class="separator:a5b570154312103ccf7482c0c2b6de2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ffcc76d19fcc673634724c8c2a0f23" id="r_af2ffcc76d19fcc673634724c8c2a0f23"><td class="memItemLeft" align="right" valign="top"><a id="af2ffcc76d19fcc673634724c8c2a0f23" name="af2ffcc76d19fcc673634724c8c2a0f23"></a>
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>previousVector</b></td></tr>
<tr class="separator:af2ffcc76d19fcc673634724c8c2a0f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cdba21cc622ac500a5fcb15231d212" id="r_af1cdba21cc622ac500a5fcb15231d212"><td class="memItemLeft" align="right" valign="top"><a id="af1cdba21cc622ac500a5fcb15231d212" name="af1cdba21cc622ac500a5fcb15231d212"></a>
Eigen::VectorX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvalues</b></td></tr>
<tr class="separator:af1cdba21cc622ac500a5fcb15231d212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc1b358cf5c42dd799e0d74ba52e863" id="r_a6fc1b358cf5c42dd799e0d74ba52e863"><td class="memItemLeft" align="right" valign="top"><a id="a6fc1b358cf5c42dd799e0d74ba52e863" name="a6fc1b358cf5c42dd799e0d74ba52e863"></a>
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvectors</b></td></tr>
<tr class="separator:a6fc1b358cf5c42dd799e0d74ba52e863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_eigenvalue_solver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_eigenvalue_solver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver&lt; Scalar &gt;</a></td></tr>
<tr class="memitem:a4d3fe671d4609b1eace96fdd375e691f inherit pro_attribs_class_eigenvalue_solver" id="r_a4d3fe671d4609b1eace96fdd375e691f"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>converged</b></td></tr>
<tr class="separator:a4d3fe671d4609b1eace96fdd375e691f inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26e235a817aecdc1dcca9fb7895877a inherit pro_attribs_class_eigenvalue_solver" id="r_ab26e235a817aecdc1dcca9fb7895877a"><td class="memItemLeft" align="right" valign="top">
Eigen::VectorX&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvalues</b></td></tr>
<tr class="separator:ab26e235a817aecdc1dcca9fb7895877a inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfa4ca80eca46340fa3f1b321d33112 inherit pro_attribs_class_eigenvalue_solver" id="r_a1dfa4ca80eca46340fa3f1b321d33112"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvectors</b></td></tr>
<tr class="separator:a1dfa4ca80eca46340fa3f1b321d33112 inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73406b02a4b863bc7a2ee9135a6fad inherit pro_attribs_class_eigenvalue_solver" id="r_a0e73406b02a4b863bc7a2ee9135a6fad"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentIteration</b></td></tr>
<tr class="separator:a0e73406b02a4b863bc7a2ee9135a6fad inherit pro_attribs_class_eigenvalue_solver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Scalar&gt;<br />
class AbstractPowerMethod&lt; Scalar &gt;</div><p>A class for solving eigenvalue problems using the power method. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td><a class="el" href="class_abstract_power_method.html" title="A class for solving eigenvalue problems using the power method.">AbstractPowerMethod</a> is an abstract class that provides the basic structure </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8489f099bef0ccd781a360d7411226c4" name="a8489f099bef0ccd781a360d7411226c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8489f099bef0ccd781a360d7411226c4">&#9670;&#160;</a></span>getEigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorX&lt; std::complex&lt; double &gt; &gt; <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::getEigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="aba213413c66a365b6ed36999f39da5c2" name="aba213413c66a365b6ed36999f39da5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba213413c66a365b6ed36999f39da5c2">&#9670;&#160;</a></span>getEigenvectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixX&lt; Scalar &gt; <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::getEigenvectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the eigenvectors. </p>
<p>This method returns the eigenvectors of the matrix. </p>

<p>Implements <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a4922cdc16e9699fabf2980ebde9df7a3" name="a4922cdc16e9699fabf2980ebde9df7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4922cdc16e9699fabf2980ebde9df7a3">&#9670;&#160;</a></span>hasConverged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::hasConverged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the eigenvalue solver has converged. </p>
<p>This method checks if the eigenvalue solver has converged. </p><dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the eigenvalue solver has converged. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_iteration_limit_exceeded.html" title="A class for exceptions thrown by the solvers when the maximum number of iterations is exceeded.">IterationLimitExceeded</a></td><td>if the iteration limit is exceeded before convergence. </td></tr>
    <tr><td class="paramname">EigenvalueSolverNotConverged</td><td>if the eigenvalue solver does not converge. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#ada3394dac3da4ec47379d8114d1ec04e">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a917fb6dda82b47b5375424123dcef374" name="a917fb6dda82b47b5375424123dcef374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917fb6dda82b47b5375424123dcef374">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the eigenvalue solver. </p>
<p>This method initializes the eigenvalue solver. </p>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#a4d2ce0911cc9cc1bb2b775da11cccd28">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a074145e5f9b7bba3b4badae2444f9657" name="a074145e5f9b7bba3b4badae2444f9657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074145e5f9b7bba3b4badae2444f9657">&#9670;&#160;</a></span>obtainResults()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::obtainResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the results of the eigenvalue solver. </p>
<p>Virtual method to be implemented by the subclasses. </p>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#a0269924d4a373b99791446caba338efd">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_inverse_power_method.html#acd9d9016085f61b24cc858bfed872dc8">InversePowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_inverse_power_method_with_shift.html#a95025eb346b33cd9d5f6066145705bf1">InversePowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_power_method.html#a727ebce3e4575428a702648842c2057d">PowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_power_method_with_shift.html#a9f8f46a4b228f0585c674c5721e00a7f">PowerMethodWithShift&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a4cd27a187ca517837cae4c3d2dc34857" name="a4cd27a187ca517837cae4c3d2dc34857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd27a187ca517837cae4c3d2dc34857">&#9670;&#160;</a></span>performIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::performIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a single iteration of the solver All solver are iterative. This function performs a single iteration of the solver. </p>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#a9258572b6e067623534edde8e81bdb23">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_inverse_power_method.html#a956edb4c02be0b9f420ca7a7baef0c60">InversePowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_inverse_power_method_with_shift.html#a241de203906c8f1d8ccdfdbb7ec02d07">InversePowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_power_method.html#a06a02899e33dc9179fa0aae97af8c897">PowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_power_method_with_shift.html#a8f7b949040c7d56bb219f686af7ae8ea">PowerMethodWithShift&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a2fd59264b44472e4106bcfbeed3cd86a" name="a2fd59264b44472e4106bcfbeed3cd86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd59264b44472e4106bcfbeed3cd86a">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixX&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matrix. </p>
<p>This method sets the matrix to be used in the eigenvalue problem. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to be used in the eigenvalue problem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#a664c54ff72cef228d987f70b6d003875">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_inverse_power_method.html#a3715e51d49cc4c787a67435e330176d3">InversePowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_inverse_power_method_with_shift.html#ad22748c8309bc7c612a0ef442c388634">InversePowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_power_method.html#ae3dc53c2eb50721cd46d22ac731ebfc3">PowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_power_method_with_shift.html#a714008d06a26fbe2511ac160fb7c509a">PowerMethodWithShift&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="acb50254522abfc125b4bda4344f86e67" name="acb50254522abfc125b4bda4344f86e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb50254522abfc125b4bda4344f86e67">&#9670;&#160;</a></span>setMaxIterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::setMaxIterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of iterations. </p>
<p>This method sets the maximum number of iterations to be used in the eigenvalue problem. </p>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#ac538598cfe094d352d10ff54831755ef">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="afaa89e944cac620e349e00dc292077cb" name="afaa89e944cac620e349e00dc292077cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa89e944cac620e349e00dc292077cb">&#9670;&#160;</a></span>setTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_abstract_power_method.html">AbstractPowerMethod</a>&lt; Scalar &gt;::setTolerance </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the tolerance. </p>
<p>This method sets the tolerance to be used in the eigenvalue problem. </p>

<p>Implements <a class="el" href="class_eigenvalue_solver.html#a575feca50c6f7268874836e3447d5668">EigenvalueSolver&lt; Scalar &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/romeu/Desktop/cse_epfl/ma3/eigenvalue-pcsc/include/algorithms/<a class="el" href="_abstract_power_method_8h_source.html">AbstractPowerMethod.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
