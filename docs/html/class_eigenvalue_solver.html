<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: EigenvalueSolver&lt; Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_eigenvalue_solver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">EigenvalueSolver&lt; Scalar &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Eigenvalue solver base class This class is the base class for all eigenvalue solvers. It provides the interface for all eigenvalue solvers. The <a class="el" href="class_eigenvalue_solver.html#afac1b76fc1caaa3cef3d41c516d0951d" title="Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method i...">solve()</a> function is the main function that should be called to solve the eigenvalue problem. The getEigenvalues() and getEigenvectors() functions can be called after the <a class="el" href="class_eigenvalue_solver.html#afac1b76fc1caaa3cef3d41c516d0951d" title="Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method i...">solve()</a> function to obtain the results.  
 <a href="class_eigenvalue_solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_eigenvalue_solver_8h_source.html">EigenvalueSolver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EigenvalueSolver&lt; Scalar &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_eigenvalue_solver.png" usemap="#EigenvalueSolver_3C_20Scalar_20_3E_map" alt=""/>
  <map id="EigenvalueSolver_3C_20Scalar_20_3E_map" name="EigenvalueSolver_3C_20Scalar_20_3E_map">
<area href="class_abstract_power_method.html" title="A class for solving eigenvalue problems using the power method." alt="AbstractPowerMethod&lt; Scalar &gt;" shape="rect" coords="378,56,620,80"/>
<area href="class_q_r_method.html" alt="QRMethod&lt; Scalar &gt;" shape="rect" coords="630,56,872,80"/>
<area href="class_inverse_power_method.html" title="A class for solving eigenvalue problems using the inverse power method." alt="InversePowerMethod&lt; Scalar &gt;" shape="rect" coords="0,112,242,136"/>
<area href="class_inverse_power_method_with_shift.html" title="A class for solving eigenvalue problems using the inverse power method with shift." alt="InversePowerMethodWithShift&lt; Scalar &gt;" shape="rect" coords="252,112,494,136"/>
<area href="class_power_method.html" title="A class for solving eigenvalue problems using the power method." alt="PowerMethod&lt; Scalar &gt;" shape="rect" coords="504,112,746,136"/>
<area href="class_power_method_with_shift.html" title="A class for solving eigenvalue problems using the power method with shift." alt="PowerMethodWithShift&lt; Scalar &gt;" shape="rect" coords="756,112,998,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c498d6e8992255afbcae1c355a8284d" id="r_a6c498d6e8992255afbcae1c355a8284d"><td class="memItemLeft" align="right" valign="top"><a id="a6c498d6e8992255afbcae1c355a8284d" name="a6c498d6e8992255afbcae1c355a8284d"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~EigenvalueSolver</b> ()</td></tr>
<tr class="memdesc:a6c498d6e8992255afbcae1c355a8284d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Eigenvalue Solver object. <br /></td></tr>
<tr class="separator:a6c498d6e8992255afbcae1c355a8284d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664c54ff72cef228d987f70b6d003875" id="r_a664c54ff72cef228d987f70b6d003875"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#a664c54ff72cef228d987f70b6d003875">setMatrix</a> (const Eigen::MatrixX&lt; Scalar &gt; &amp;matrix)=0</td></tr>
<tr class="memdesc:a664c54ff72cef228d987f70b6d003875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix to solve the eigenvalue problem for.  <br /></td></tr>
<tr class="separator:a664c54ff72cef228d987f70b6d003875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac538598cfe094d352d10ff54831755ef" id="r_ac538598cfe094d352d10ff54831755ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#ac538598cfe094d352d10ff54831755ef">setMaxIterations</a> (int maxIter)=0</td></tr>
<tr class="memdesc:ac538598cfe094d352d10ff54831755ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of iterations to perform. This function sets the maximum number of iterations to perform before the solver stops. The solver will stop if it has converged before the maximum number of iterations is reached.  <br /></td></tr>
<tr class="separator:ac538598cfe094d352d10ff54831755ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575feca50c6f7268874836e3447d5668" id="r_a575feca50c6f7268874836e3447d5668"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#a575feca50c6f7268874836e3447d5668">setTolerance</a> (Scalar tol)=0</td></tr>
<tr class="memdesc:a575feca50c6f7268874836e3447d5668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the tolerance for the solver. This function sets the tolerance for the solver. The solver will stop when the residual is less than the tolerance.  <br /></td></tr>
<tr class="separator:a575feca50c6f7268874836e3447d5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac1b76fc1caaa3cef3d41c516d0951d" id="r_afac1b76fc1caaa3cef3d41c516d0951d"><td class="memItemLeft" align="right" valign="top"><a id="afac1b76fc1caaa3cef3d41c516d0951d" name="afac1b76fc1caaa3cef3d41c516d0951d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> ()</td></tr>
<tr class="memdesc:afac1b76fc1caaa3cef3d41c516d0951d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method implemented by the solver. It will perform iterations until the solver has converged to the desired tolerance. The results can be obtained using the getEigenvalues() and getEigenvectors() functions. <br /></td></tr>
<tr class="separator:afac1b76fc1caaa3cef3d41c516d0951d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4048c6318a24a71e3f537a2785b911e" id="r_af4048c6318a24a71e3f537a2785b911e"><td class="memItemLeft" align="right" valign="top"><a id="af4048c6318a24a71e3f537a2785b911e" name="af4048c6318a24a71e3f537a2785b911e"></a>
virtual Eigen::VectorX&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getEigenvalues</b> () const</td></tr>
<tr class="separator:af4048c6318a24a71e3f537a2785b911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8961c41aa8412bc07f3a916c5f74ef" id="r_a8c8961c41aa8412bc07f3a916c5f74ef"><td class="memItemLeft" align="right" valign="top">virtual Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#a8c8961c41aa8412bc07f3a916c5f74ef">getEigenvectors</a> () const =0</td></tr>
<tr class="separator:a8c8961c41aa8412bc07f3a916c5f74ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4d2ce0911cc9cc1bb2b775da11cccd28" id="r_a4d2ce0911cc9cc1bb2b775da11cccd28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#a4d2ce0911cc9cc1bb2b775da11cccd28">initialize</a> ()=0</td></tr>
<tr class="memdesc:a4d2ce0911cc9cc1bb2b775da11cccd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the solver Perform any variable initialization here.  <br /></td></tr>
<tr class="separator:a4d2ce0911cc9cc1bb2b775da11cccd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3394dac3da4ec47379d8114d1ec04e" id="r_ada3394dac3da4ec47379d8114d1ec04e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#ada3394dac3da4ec47379d8114d1ec04e">hasConverged</a> ()=0</td></tr>
<tr class="memdesc:ada3394dac3da4ec47379d8114d1ec04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the solver has converged Using the current iteration and the tolerance, check if the solver has converged to the desired tolerance.  <br /></td></tr>
<tr class="separator:ada3394dac3da4ec47379d8114d1ec04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9258572b6e067623534edde8e81bdb23" id="r_a9258572b6e067623534edde8e81bdb23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#a9258572b6e067623534edde8e81bdb23">performIteration</a> ()=0</td></tr>
<tr class="memdesc:a9258572b6e067623534edde8e81bdb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single iteration of the solver All solver are iterative. This function performs a single iteration of the solver.  <br /></td></tr>
<tr class="separator:a9258572b6e067623534edde8e81bdb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0269924d4a373b99791446caba338efd" id="r_a0269924d4a373b99791446caba338efd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigenvalue_solver.html#a0269924d4a373b99791446caba338efd">obtainResults</a> ()=0</td></tr>
<tr class="memdesc:a0269924d4a373b99791446caba338efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the results of the solver This function is to be called after the solver has converged. It obtains the eigenvalues and eigenvectors from the solver and store them in the appropriate member variables.  <br /></td></tr>
<tr class="separator:a0269924d4a373b99791446caba338efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4d3fe671d4609b1eace96fdd375e691f" id="r_a4d3fe671d4609b1eace96fdd375e691f"><td class="memItemLeft" align="right" valign="top"><a id="a4d3fe671d4609b1eace96fdd375e691f" name="a4d3fe671d4609b1eace96fdd375e691f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>converged</b></td></tr>
<tr class="separator:a4d3fe671d4609b1eace96fdd375e691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26e235a817aecdc1dcca9fb7895877a" id="r_ab26e235a817aecdc1dcca9fb7895877a"><td class="memItemLeft" align="right" valign="top"><a id="ab26e235a817aecdc1dcca9fb7895877a" name="ab26e235a817aecdc1dcca9fb7895877a"></a>
Eigen::VectorX&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvalues</b></td></tr>
<tr class="separator:ab26e235a817aecdc1dcca9fb7895877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfa4ca80eca46340fa3f1b321d33112" id="r_a1dfa4ca80eca46340fa3f1b321d33112"><td class="memItemLeft" align="right" valign="top"><a id="a1dfa4ca80eca46340fa3f1b321d33112" name="a1dfa4ca80eca46340fa3f1b321d33112"></a>
Eigen::MatrixX&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvectors</b></td></tr>
<tr class="separator:a1dfa4ca80eca46340fa3f1b321d33112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73406b02a4b863bc7a2ee9135a6fad" id="r_a0e73406b02a4b863bc7a2ee9135a6fad"><td class="memItemLeft" align="right" valign="top"><a id="a0e73406b02a4b863bc7a2ee9135a6fad" name="a0e73406b02a4b863bc7a2ee9135a6fad"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentIteration</b></td></tr>
<tr class="separator:a0e73406b02a4b863bc7a2ee9135a6fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Scalar&gt;<br />
class EigenvalueSolver&lt; Scalar &gt;</div><p>Eigenvalue solver base class This class is the base class for all eigenvalue solvers. It provides the interface for all eigenvalue solvers. The <a class="el" href="class_eigenvalue_solver.html#afac1b76fc1caaa3cef3d41c516d0951d" title="Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method i...">solve()</a> function is the main function that should be called to solve the eigenvalue problem. The getEigenvalues() and getEigenvectors() functions can be called after the <a class="el" href="class_eigenvalue_solver.html#afac1b76fc1caaa3cef3d41c516d0951d" title="Solve the eigenvalue problem This function solves the eigenvalue problem using the iterative method i...">solve()</a> function to obtain the results. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the matrix to solve the eigenvalue problem for. This can be one of float, double, std::complex&lt;float&gt;, or std::complex&lt;double&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This class is not meant to be used directly. Use one of the derived classes instead. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c8961c41aa8412bc07f3a916c5f74ef" name="a8c8961c41aa8412bc07f3a916c5f74ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8961c41aa8412bc07f3a916c5f74ef">&#9670;&#160;</a></span>getEigenvectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Eigen::MatrixX&lt; Scalar &gt; <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::getEigenvectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_abstract_power_method.html#aba213413c66a365b6ed36999f39da5c2">AbstractPowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_q_r_method.html#a775890d428e95ff10283e91ca789f141">QRMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="ada3394dac3da4ec47379d8114d1ec04e" name="ada3394dac3da4ec47379d8114d1ec04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3394dac3da4ec47379d8114d1ec04e">&#9670;&#160;</a></span>hasConverged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::hasConverged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the solver has converged Using the current iteration and the tolerance, check if the solver has converged to the desired tolerance. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the solver has converged, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="class_abstract_power_method.html#a4922cdc16e9699fabf2980ebde9df7a3">AbstractPowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_q_r_method.html#a08d2961f9ea9f82cbff74f2474c144a4">QRMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a4d2ce0911cc9cc1bb2b775da11cccd28" name="a4d2ce0911cc9cc1bb2b775da11cccd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2ce0911cc9cc1bb2b775da11cccd28">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the solver Perform any variable initialization here. </p>

<p>Implemented in <a class="el" href="class_abstract_power_method.html#a917fb6dda82b47b5375424123dcef374">AbstractPowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_q_r_method.html#abfc9618ff33f6bdd2f6ecdd21d730410">QRMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a0269924d4a373b99791446caba338efd" name="a0269924d4a373b99791446caba338efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0269924d4a373b99791446caba338efd">&#9670;&#160;</a></span>obtainResults()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::obtainResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the results of the solver This function is to be called after the solver has converged. It obtains the eigenvalues and eigenvectors from the solver and store them in the appropriate member variables. </p>

<p>Implemented in <a class="el" href="class_inverse_power_method.html#acd9d9016085f61b24cc858bfed872dc8">InversePowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_inverse_power_method_with_shift.html#a95025eb346b33cd9d5f6066145705bf1">InversePowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_power_method.html#a727ebce3e4575428a702648842c2057d">PowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_power_method_with_shift.html#a9f8f46a4b228f0585c674c5721e00a7f">PowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_q_r_method.html#a43385ddc7f4da4c9596130076b7a8608">QRMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_abstract_power_method.html#a074145e5f9b7bba3b4badae2444f9657">AbstractPowerMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a9258572b6e067623534edde8e81bdb23" name="a9258572b6e067623534edde8e81bdb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9258572b6e067623534edde8e81bdb23">&#9670;&#160;</a></span>performIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::performIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a single iteration of the solver All solver are iterative. This function performs a single iteration of the solver. </p>

<p>Implemented in <a class="el" href="class_inverse_power_method.html#a956edb4c02be0b9f420ca7a7baef0c60">InversePowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_inverse_power_method_with_shift.html#a241de203906c8f1d8ccdfdbb7ec02d07">InversePowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_power_method.html#a06a02899e33dc9179fa0aae97af8c897">PowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_power_method_with_shift.html#a8f7b949040c7d56bb219f686af7ae8ea">PowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_q_r_method.html#afbf15ce3ce3657017d481bf153c7699a">QRMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_abstract_power_method.html#a4cd27a187ca517837cae4c3d2dc34857">AbstractPowerMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a664c54ff72cef228d987f70b6d003875" name="a664c54ff72cef228d987f70b6d003875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664c54ff72cef228d987f70b6d003875">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixX&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matrix to solve the eigenvalue problem for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to solve the eigenvalue problem for. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_inverse_power_method.html#a3715e51d49cc4c787a67435e330176d3">InversePowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_inverse_power_method_with_shift.html#ad22748c8309bc7c612a0ef442c388634">InversePowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_power_method.html#ae3dc53c2eb50721cd46d22ac731ebfc3">PowerMethod&lt; Scalar &gt;</a>, <a class="el" href="class_power_method_with_shift.html#a714008d06a26fbe2511ac160fb7c509a">PowerMethodWithShift&lt; Scalar &gt;</a>, <a class="el" href="class_abstract_power_method.html#a2fd59264b44472e4106bcfbeed3cd86a">AbstractPowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_q_r_method.html#aba3de462789c2c01a1ef40add6c757d1">QRMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="ac538598cfe094d352d10ff54831755ef" name="ac538598cfe094d352d10ff54831755ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac538598cfe094d352d10ff54831755ef">&#9670;&#160;</a></span>setMaxIterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::setMaxIterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of iterations to perform. This function sets the maximum number of iterations to perform before the solver stops. The solver will stop if it has converged before the maximum number of iterations is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxIter</td><td>The maximum number of iterations to perform </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_abstract_power_method.html#acb50254522abfc125b4bda4344f86e67">AbstractPowerMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_q_r_method.html#a4460719122785d202d71ecdc32ab0513">QRMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<a id="a575feca50c6f7268874836e3447d5668" name="a575feca50c6f7268874836e3447d5668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575feca50c6f7268874836e3447d5668">&#9670;&#160;</a></span>setTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_eigenvalue_solver.html">EigenvalueSolver</a>&lt; Scalar &gt;::setTolerance </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the tolerance for the solver. This function sets the tolerance for the solver. The solver will stop when the residual is less than the tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>The tolerance for the solver </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_q_r_method.html#a75be6d34e80d72ab8307bc86a5587e09">QRMethod&lt; Scalar &gt;</a>, and <a class="el" href="class_abstract_power_method.html#afaa89e944cac620e349e00dc292077cb">AbstractPowerMethod&lt; Scalar &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/romeu/Desktop/cse_epfl/ma3/eigenvalue-pcsc/include/algorithms/<a class="el" href="_eigenvalue_solver_8h_source.html">EigenvalueSolver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
